<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basalt â€” Play</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <style>
        html, body { overflow: hidden; width: 100%; height: 100%; margin: 0; padding: 0; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; position: relative; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; outline: none; display: block; }
        #ui-overlay { display: none !important; }
        .ui-btn { background: rgba(45, 45, 45, 0.8); color: white; border: 1px solid #555; padding: 8px 12px; cursor: pointer; font-size: 12px; border-radius: 4px; text-align: center; user-select: none; }
        .ui-btn:hover { background: rgba(80, 80, 80, 0.9); }

        #crosshair-overlay {
            position: absolute; inset: 0; pointer-events: none; display: flex; align-items: center; justify-content: center; z-index: 10;
        }
        #crosshair-flexer {
            --sway-x: 0px; --sway-y: 0px; --gap: 24px; --len: 18px; --thick: 2px;
            position: relative; display: flex; align-items: center; justify-content: center;
            width: calc(var(--gap) + var(--len) * 2); height: calc(var(--gap) + var(--len) * 2);
            transform: translate(calc(var(--sway-x)), calc(var(--sway-y)));
            transition: transform 0.12s cubic-bezier(0.25, 0.46, 0.45, 0.94), width 0.15s ease-out, height 0.15s ease-out;
        }
        #crosshair-flexer.ads { opacity: 0; transition: opacity 0.1s ease-out; }
        .ch-bar { background: white; box-shadow: 0 0 0 1px black; position: absolute; }
        .ch-bar.v { width: var(--thick); height: var(--len); }
        .ch-bar.h { width: var(--len); height: var(--thick); }
        .ch-bar.top { top: calc(-1 * (var(--gap) / 2 + var(--len))); left: 50%; transform: translateX(-50%); }
        .ch-bar.bot { bottom: calc(-1 * (var(--gap) / 2 + var(--len))); left: 50%; transform: translateX(-50%); }
        .ch-bar.left { left: calc(-1 * (var(--gap) / 2 + var(--len))); top: 50%; transform: translateY(-50%); }
        .ch-bar.right { right: calc(-1 * (var(--gap) / 2 + var(--len))); top: 50%; transform: translateY(-50%); }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="ui-overlay">
        <a href="Editor_Layout.html" class="ui-btn">Editor Layout</a>
        <div class="ui-btn" id="inspector-btn">Toggle Inspector</div>
        <div class="ui-btn" id="stats-btn">Toggle Stats</div>
    </div>
    <div id="crosshair-overlay">
        <div id="crosshair-flexer">
            <div class="ch-bar v top"></div>
            <div class="ch-bar v bot"></div>
            <div class="ch-bar h left"></div>
            <div class="ch-bar h right"></div>
        </div>
    </div>
    <script type="module">
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const MOUSE_SENSITIVITY = 0.0002;
        const MAP_SIZE = 80;
        const PLAYER_HEIGHT = 1.7;
        const BASE_HEAD_POS = new BABYLON.Vector3(-0.03, 0.04, -0.24);
        const ADS_HEAD_POS = new BABYLON.Vector3(-0.10, 0.07, 0.1);
        const CAM_GLOBAL_OFFSET = new BABYLON.Vector3(0, 0, 0);
        const WALK_SPEED = 0.12;
        const SPRINT_SPEED = 0.22;
        const JUMP_FORCE = 0.15;
        const GRAVITY = -0.008;
        const AIR_DRAG = 0.98;
        const AIR_ACCELERATION = 0.4;
        const GROUND_FRICTION = 0.85;
        const APEX_THRESHOLD = 0.02;
        const APEX_GRAVITY_MULT = 0.5;
        const BULLET_EMITTER_OFFSET = new BABYLON.Vector3(0, 0, 0);
        const BULLET_EMITTER_ADS_OFFSET = new BABYLON.Vector3(0, 0, 0);
        const FIRE_RATE = 100;
        const RECOIL_STRENGTH_UP = -0.01;
        const RECOIL_STRENGTH_BACK = -0.04;
        const RECOIL_STRENGTH_SIDE = 0;
        const RECOIL_RECOVERY = 0.15;

        const CROSSHAIR_BOB_SPEED = 4.2;
        const CROSSHAIR_BOB_AMOUNT_WALK = 2.5;
        const CROSSHAIR_BOB_AMOUNT_SPRINT = 5;
        const CROSSHAIR_BASE_GAP = 24;
        const CROSSHAIR_WALK_GAP = 40;
        const CROSSHAIR_SPRINT_GAP = 80;
        const CROSSHAIR_RECOIL_BLOOM = 15;
        const CROSSHAIR_SWAY_SCALE = 200;
        const CROSSHAIR_SWAY_INFLUENCE = 0.5;

        var WEAPONS = [
            { url: "https://dl.dropbox.com/s/wbia4zetn1bdeze/", file: "arms_assault_rifle_02.glb", hideList: ["knife", "assault_rifle_02_iron_sights", "bullet", "scope_01", "scope_02", "scope_03", "silencer"] },
            { url: "https://dl.dropbox.com/s/axejnxioiwq155l/", file: "arms_handgun_01.glb", hideList: ["knife", "scope_02", "scope_03", "silencer"] }
        ];

        var player, keys = { left: 0, right: 0, forward: 0, back: 0, shift: 0, jump: 0, weapon1: 0, weapon2: 0, scrollUp: 0, scrollDown: 0 };
        var isAds = false, verticalVelocity = 0, isGrounded = true;
        var velocityXZ = new BABYLON.Vector3(0, 0, 0), airMaxSpeed = 0;
        var jumpCount = 0, bulletCount = 0, isFiring = false, lastFireTime = 0;
        var currentRecoilPos = new BABYLON.Vector3(0, 0, 0);
        var weaponSlot = 0, weaponRoot = null, currentIdle = null, currentWalk = null, cameraNode = null;
        var statsText, scene;
        var bobPhase = 0;
        var recoilBloom = 0;

        function updateCrosshairHTML(isMoving, isSprinting, isFiring, isAds, recoilX, recoilY, deltaTime) {
            var flexer = document.getElementById("crosshair-flexer");
            if (!flexer) return;
            flexer.classList.toggle("ads", isAds);
            if (isAds) return;

            var gap = CROSSHAIR_BASE_GAP;
            if (isMoving) gap = isSprinting ? CROSSHAIR_SPRINT_GAP : CROSSHAIR_WALK_GAP;
            if (isFiring) { recoilBloom += CROSSHAIR_RECOIL_BLOOM * 0.25; if (recoilBloom > 60) recoilBloom = 60; }
            recoilBloom *= 1 - RECOIL_RECOVERY;
            gap += recoilBloom;
            flexer.style.setProperty("--gap", gap + "px");

            bobPhase += (deltaTime || 16) * 0.001 * CROSSHAIR_BOB_SPEED;
            var bobAmount = isMoving ? (isSprinting ? CROSSHAIR_BOB_AMOUNT_SPRINT : CROSSHAIR_BOB_AMOUNT_WALK) : 0;
            var bobX = bobAmount * Math.sin(bobPhase);
            var bobY = bobAmount * Math.cos(bobPhase * 0.5);
            var swayX = bobX + recoilX * CROSSHAIR_SWAY_SCALE * CROSSHAIR_SWAY_INFLUENCE;
            var swayY = bobY + recoilY * CROSSHAIR_SWAY_SCALE * CROSSHAIR_SWAY_INFLUENCE;
            flexer.style.setProperty("--sway-x", swayX + "px");
            flexer.style.setProperty("--sway-y", swayY + "px");
        }

        function createScene() {
            scene = new BABYLON.Scene(engine);
            scene.useRightHandedSystem = true;
            scene.clearColor = new BABYLON.Color4(0.4, 0.5, 0.6, 1);

            var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.7;

            var mat1 = new BABYLON.StandardMaterial("mat0", scene);
            mat1.diffuseTexture = new BABYLON.Texture("https://i.imgur.com/HADnUQr.png", scene);
            mat1.diffuseTexture.uScale = MAP_SIZE;
            mat1.diffuseTexture.vScale = MAP_SIZE;

            var ground = BABYLON.MeshBuilder.CreateGround("ground", { height: MAP_SIZE, width: MAP_SIZE, subdivisions: 4 }, scene);
            ground.material = mat1;
            ground.checkCollisions = true;

            var head = BABYLON.MeshBuilder.CreateSphere("headAnchor", { diameter: 0.05 }, scene, true);
            head.material = new BABYLON.StandardMaterial("headMat", scene);
            head.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
            head.isVisible = false;

            var box = BABYLON.MeshBuilder.CreateBox("targetBox", { size: 1 }, scene);
            box.isVisible = false;
            for (var i = 0; i < MAP_SIZE / 2; i++) {
                var inst = box.createInstance('targetInstance_' + i);
                inst.position = new BABYLON.Vector3(Math.floor(Math.random() * MAP_SIZE) - MAP_SIZE / 2, 0.5, Math.floor(Math.random() * MAP_SIZE) - MAP_SIZE / 2);
            }

            player = new BABYLON.TransformNode("playerRoot", scene);
            player.position = new BABYLON.Vector3(0, PLAYER_HEIGHT, 0);

            var fpsCamera = new BABYLON.UniversalCamera("FPS_Camera", new BABYLON.Vector3(0, 0, 0), scene);
            fpsCamera.parent = player;
            scene.activeCamera = fpsCamera;
            fpsCamera.minZ = 0.0001;

            var mouseMove = function (e) {
                var dt = engine.getDeltaTime();
                if (player) {
                    player.rotation.x += (e.movementY || 0) * dt * MOUSE_SENSITIVITY;
                    player.rotation.y -= (e.movementX || 0) * dt * MOUSE_SENSITIVITY;
                    player.rotation.x = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, player.rotation.x));
                }
            };
            var changeCallback = function () {
                if (document.pointerLockElement === canvas) document.addEventListener("mousemove", mouseMove, false);
                else document.removeEventListener("mousemove", mouseMove, false);
            };
            document.addEventListener('pointerlockchange', changeCallback, false);
            canvas.onclick = function () { if (!scene.debugLayer.isVisible()) canvas.requestPointerLock(); };

            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('HUD');

            statsText = new BABYLON.GUI.TextBlock();
            statsText.text = "FPS: 0\nBullets: 0\nJumps: 0";
            statsText.color = "white"; statsText.fontSize = 18;
            statsText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            statsText.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            statsText.left = "20px"; statsText.top = "20px";
            advancedTexture.addControl(statsText);

            var buildInfo = new BABYLON.GUI.TextBlock();
            buildInfo.text = "Iron Will First Person WebGPU Engine with Babylon 8 and HavokSDK 5 - (Experimental Renderer).";
            buildInfo.color = "rgba(255,255,255,0.6)"; buildInfo.fontSize = 14;
            buildInfo.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            buildInfo.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            buildInfo.left = "-20px"; buildInfo.top = "-20px";
            advancedTexture.addControl(buildInfo);

            window.addEventListener("keydown", function (evt) {
                if (evt.keyCode == 87) keys.forward = 1;
                if (evt.keyCode == 83) keys.back = 1;
                if (evt.keyCode == 68) keys.left = 1;
                if (evt.keyCode == 65) keys.right = 1;
                if (evt.keyCode == 16) keys.shift = 1;
                if (evt.keyCode == 32) keys.jump = 1;
                if (evt.keyCode == 49) keys.weapon1 = 1;
                if (evt.keyCode == 50) keys.weapon2 = 1;
            });
            window.addEventListener("keyup", function (evt) {
                if (evt.keyCode == 87) keys.forward = 0;
                if (evt.keyCode == 83) keys.back = 0;
                if (evt.keyCode == 68) keys.left = 0;
                if (evt.keyCode == 65) keys.right = 0;
                if (evt.keyCode == 16) keys.shift = 0;
                if (evt.keyCode == 32) keys.jump = 0;
                if (evt.keyCode == 49) keys.weapon1 = 0;
                if (evt.keyCode == 50) keys.weapon2 = 0;
            });
            window.addEventListener("wheel", function (evt) {
                if (evt.deltaY < 0) keys.scrollUp = 1;
                else if (evt.deltaY > 0) keys.scrollDown = 1;
            }, { passive: true });

            function loadWeapon(slot, headRef) {
                var w = WEAPONS[slot];
                if (!w) return;
                if (currentIdle) try { currentIdle.stop(); } catch (_) {}
                if (currentWalk) try { currentWalk.stop(); } catch (_) {}
                if (headRef) headRef.parent = null;
                if (weaponRoot) try { weaponRoot.dispose(); } catch (_) {}
                weaponSlot = slot;
                currentRecoilPos.set(0, 0, 0);
                BABYLON.SceneLoader.ImportMeshAsync("", w.url, w.file, scene).then(function (result) {
                    var newMeshes = result.meshes;
                    if (!newMeshes || !newMeshes.length) return;
                    weaponRoot = newMeshes[0];
                    weaponRoot.parent = player;
                    weaponRoot.position.set(0, 0, 0);
                    weaponRoot.rotation.set(0, 0, 0);
                    weaponRoot.scaling.set(1, 1, 1);
                    cameraNode = scene.getNodeByName('camera');
                    if (cameraNode && headRef) {
                        headRef.parent = cameraNode;
                        headRef.position.copyFrom(BASE_HEAD_POS);
                        headRef.rotation.set(0, 0, 0);
                    }
                    var ag = result.animationGroups || [];
                    currentIdle = ag.find(function (a) { return a.name === "idle"; }) || scene.getAnimationGroupByName("idle");
                    currentWalk = ag.find(function (a) { return a.name === "walk"; }) || scene.getAnimationGroupByName("walk");
                    w.hideList.forEach(function (name) {
                        var m = scene.getMeshByName(name) || scene.getNodeByName(name);
                        if (m) m.setEnabled(false);
                    });
                    isWalking = false;
                    if (currentIdle) currentIdle.start(true);
                }).catch(function (err) { console.warn("loadWeapon error:", err); });
            }

            loadWeapon(0, head);
            var isWalking = false;

            scene.onPointerDown = function (evt) {
                if (evt.button === 0) isFiring = true;
                if (evt.button === 2) isAds = true;
            };
            scene.onPointerUp = function (evt) {
                if (evt.button === 0) isFiring = false;
                if (evt.button === 2) isAds = false;
            };

            var prevWeapon1 = 0, prevWeapon2 = 0, prevScrollUp = 0, prevScrollDown = 0;
            scene.onBeforeRenderObservable.add(function () {
                var deltaTime = engine.getDeltaTime();
                var now = Date.now();
                statsText.text = "FPS: " + Math.round(engine.getFps()) + " (" + Math.round(deltaTime) + " ms)\nBullets: " + bulletCount + "\nJumps: " + jumpCount + "\nWeapon: " + (weaponSlot === 0 ? "Rifle" : "Pistol");

                var isMoving = !!(keys.forward || keys.back || keys.left || keys.right);
                var isSprinting = isMoving && keys.shift && !isAds;
                updateCrosshairHTML(isMoving, isSprinting, isFiring, isAds, currentRecoilPos.x, currentRecoilPos.y, deltaTime);

                if (keys.weapon1 && !prevWeapon1) loadWeapon(0, head);
                prevWeapon1 = keys.weapon1;
                if (keys.weapon2 && !prevWeapon2) loadWeapon(1, head);
                prevWeapon2 = keys.weapon2;
                if (keys.scrollUp && !prevScrollUp) { loadWeapon((weaponSlot + 1) % 2, head); }
                prevScrollUp = keys.scrollUp;
                if (keys.scrollDown && !prevScrollDown) { loadWeapon((weaponSlot + 1) % 2, head); }
                prevScrollDown = keys.scrollDown;
                keys.scrollUp = 0;
                keys.scrollDown = 0;

                if (isFiring && now - lastFireTime > FIRE_RATE) {
                    bulletCount++;
                    lastFireTime = now;
                    var ray = fpsCamera.getForwardRay(100);
                    var pickInfo = scene.pickWithRay(ray, function (mesh) { return mesh !== ground && mesh.isPickable; });
                    var targetPoint = pickInfo.hit ? pickInfo.pickedPoint : ray.origin.add(ray.direction.scale(100));
                    var offset = isAds ? BULLET_EMITTER_ADS_OFFSET : BULLET_EMITTER_OFFSET;
                    var bulletOrigin = BABYLON.Vector3.TransformCoordinates(offset, fpsCamera.getWorldMatrix());
                    var tracer = BABYLON.MeshBuilder.CreateLines("tracer", { points: [bulletOrigin, bulletOrigin.add(targetPoint.subtract(bulletOrigin).normalize().scale(0.5))] }, scene);
                    tracer.color = new BABYLON.Color3(1, 0.8, 0.2);
                    setTimeout(function () { tracer.dispose(); }, 50);
                    currentRecoilPos.x += (Math.random() - 0.5) * RECOIL_STRENGTH_SIDE;
                    currentRecoilPos.y += RECOIL_STRENGTH_UP;
                    currentRecoilPos.z -= RECOIL_STRENGTH_BACK;
                }
                currentRecoilPos = BABYLON.Vector3.Lerp(currentRecoilPos, BABYLON.Vector3.Zero(), RECOIL_RECOVERY * (deltaTime / 16));

                var currentSpeed = (keys.shift && !isAds) ? SPRINT_SPEED : WALK_SPEED;
                var moveVector = BABYLON.Vector3.Zero();
                var rotMat = BABYLON.Matrix.RotationY(player.rotation.y);
                var forwardDir = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(0, 0, 1), rotMat);
                var rightDir = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(1, 0, 0), rotMat);
                if (keys.forward) moveVector.addInPlace(forwardDir);
                if (keys.back) moveVector.subtractInPlace(forwardDir);
                if (keys.left) moveVector.subtractInPlace(rightDir);
                if (keys.right) moveVector.addInPlace(rightDir);
                var hasInput = moveVector.lengthSquared() > 0;
                if (hasInput) moveVector.normalize();

                if (isGrounded) {
                    if (hasInput) {
                        var accel = currentSpeed * 0.35;
                        velocityXZ.addInPlace(moveVector.scale(accel));
                        var len = Math.sqrt(velocityXZ.x * velocityXZ.x + velocityXZ.z * velocityXZ.z);
                        if (len > currentSpeed) velocityXZ.scaleInPlace(currentSpeed / len);
                    } else {
                        velocityXZ.scaleInPlace(GROUND_FRICTION);
                        if (velocityXZ.lengthSquared() < 1e-6) velocityXZ.set(0, 0, 0);
                    }
                } else {
                    if (airMaxSpeed <= 0) {
                        var len = Math.sqrt(velocityXZ.x * velocityXZ.x + velocityXZ.z * velocityXZ.z);
                        airMaxSpeed = Math.max(currentSpeed, len);
                    }
                    if (hasInput) {
                        var airAccel = airMaxSpeed * AIR_ACCELERATION * 0.25;
                        velocityXZ.addInPlace(moveVector.scale(airAccel));
                    }
                    velocityXZ.scaleInPlace(AIR_DRAG);
                    var len = Math.sqrt(velocityXZ.x * velocityXZ.x + velocityXZ.z * velocityXZ.z);
                    if (len > airMaxSpeed) velocityXZ.scaleInPlace(airMaxSpeed / len);
                }
                player.position.addInPlace(velocityXZ);

                if (currentIdle && currentWalk) {
                    var movementSpeed = Math.sqrt(velocityXZ.x * velocityXZ.x + velocityXZ.z * velocityXZ.z);
                    var shouldWalk = !isAds && !isFiring && movementSpeed > 0.08;
                    if (shouldWalk && !isWalking) { currentIdle.stop(); currentWalk.start(true); isWalking = true; }
                    else if (!shouldWalk && isWalking) { currentWalk.stop(); currentIdle.start(true); isWalking = false; }
                }

                if (isGrounded) {
                    if (keys.jump) { verticalVelocity = JUMP_FORCE; isGrounded = false; airMaxSpeed = currentSpeed; jumpCount++; }
                } else {
                    var g = (Math.abs(verticalVelocity) < APEX_THRESHOLD) ? GRAVITY * APEX_GRAVITY_MULT : GRAVITY;
                    verticalVelocity += g;
                    if (verticalVelocity < 0) verticalVelocity *= AIR_DRAG;
                    player.position.y += verticalVelocity;
                    if (player.position.y <= PLAYER_HEIGHT) { player.position.y = PLAYER_HEIGHT; verticalVelocity = 0; velocityXZ.scaleInPlace(0.7); isGrounded = true; airMaxSpeed = 0; }
                }

                if (cameraNode) {
                    var modePos = isAds ? ADS_HEAD_POS : BASE_HEAD_POS;
                    var targetPos = modePos.add(currentRecoilPos).add(CAM_GLOBAL_OFFSET);
                    head.position = BABYLON.Vector3.Lerp(head.position, targetPos, 0.2 * (deltaTime / 16));
                    fpsCamera.position.copyFrom(head.position);
                }
            });

            document.getElementById("inspector-btn").onclick = function () {
                if (scene.debugLayer.isVisible()) scene.debugLayer.hide();
                else scene.debugLayer.show({ embedMode: true });
            };
            document.getElementById("stats-btn").onclick = function () {
                if (statsText) statsText.isVisible = !statsText.isVisible;
            };

            return scene;
        }

        var sceneInstance = createScene();
        engine.runRenderLoop(function () { if (sceneInstance) sceneInstance.render(); });
        window.addEventListener("resize", function () { engine.resize(); });

        if (typeof window !== 'undefined' && window !== window.top) {
            window.basaltScene = sceneInstance;
            try { window.parent.postMessage({ type: 'basalt_scene_ready' }, '*'); } catch (_) {}
        }
    </script>
</body>
</html>
